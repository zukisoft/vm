//-----------------------------------------------------------------------------
// Copyright (c) 2014 Michael G. Brehm
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//-----------------------------------------------------------------------------

import "wtypes.idl";				// Import Win32 type declarations

//-----------------------------------------------------------------------------
// Type Declarations

// stdint typedefs
//
typedef signed char					int8_t;
typedef unsigned char				uint8_t;
typedef short						int16_t;
typedef unsigned short				uint16_t;
typedef __int32						int32_t;
typedef unsigned __int32			uint32_t;
typedef __int64						int64_t;
typedef unsigned __int64			uint64_t;

// charptr_t / wcharptr_t - [unique] character string pointers
//
typedef [string, unique] char*		charptr_t;
typedef [string, unique] wchar_t*	wcharptr_t;

// LINUX
// TODO: WORDS
typedef unsigned __int32			dev_t;
typedef unsigned __int32			gid_t;
typedef unsigned __int32			mode_t;
typedef unsigned __int32			uid_t;

// fshandle_t - filesystem node handle
//
typedef unsigned __int64			fshandle_t;

//
// MOVE UAPI STUFF TO A UAPI.IDL FILE, THIS WILL GENERATE UAPI.H
//

//
// LINUX ERROR CODES
//
const __int3264 LINUX_EPERM             = 1;              /* Operation not permitted */
const __int3264 LINUX_ENOENT            = 2;              /* No such file or directory */
const __int3264 LINUX_ESRCH             = 3;              /* No such process */
const __int3264 LINUX_EINTR             = 4;              /* Interrupted system call */
const __int3264 LINUX_EIO               = 5;              /* I/O error */
const __int3264 LINUX_ENXIO             = 6;              /* No such device or address */
const __int3264 LINUX_E2BIG             = 7;              /* Argument list too long */
const __int3264 LINUX_ENOEXEC           = 8;              /* Exec format error */
const __int3264 LINUX_EBADF             = 9;              /* Bad file number */
const __int3264 LINUX_ECHILD            = 10;             /* No child processes */
const __int3264 LINUX_EAGAIN            = 11;             /* Try again */
const __int3264 LINUX_ENOMEM            = 12;             /* Out of memory */
const __int3264 LINUX_EACCES            = 13;             /* Permission denied */
const __int3264 LINUX_EFAULT            = 14;             /* Bad address */
const __int3264 LINUX_ENOTBLK           = 15;             /* Block device required */
const __int3264 LINUX_EBUSY             = 16;             /* Device or resource busy */
const __int3264 LINUX_EEXIST            = 17;             /* File exists */
const __int3264 LINUX_EXDEV             = 18;             /* Cross-device link */
const __int3264 LINUX_ENODEV            = 19;             /* No such device */
const __int3264 LINUX_ENOTDIR           = 20;             /* Not a directory */
const __int3264 LINUX_EISDIR            = 21;             /* Is a directory */
const __int3264 LINUX_EINVAL            = 22;             /* Invalid argument */
const __int3264 LINUX_ENFILE            = 23;             /* File table overflow */
const __int3264 LINUX_EMFILE            = 24;             /* Too many open files */
const __int3264 LINUX_ENOTTY            = 25;             /* Not a typewriter */
const __int3264 LINUX_ETXTBSY           = 26;             /* Text file busy */
const __int3264 LINUX_EFBIG             = 27;             /* File too large */
const __int3264 LINUX_ENOSPC            = 28;             /* No space left on device */
const __int3264 LINUX_ESPIPE            = 29;             /* Illegal seek */
const __int3264 LINUX_EROFS             = 30;             /* Read-only file system */
const __int3264 LINUX_EMLINK            = 31;             /* Too many links */
const __int3264 LINUX_EPIPE             = 32;             /* Broken pipe */
const __int3264 LINUX_EDOM              = 33;             /* Math argument out of domain of func */
const __int3264 LINUX_ERANGE            = 34;             /* Math result not representable */
// ...
const __int3264 LINUX_ENOSYS            = 38;             /* Function not implemented */
// ...

//-----------------------------------------------------------------------------
// fsobjecttype_t
//
// Enumeration that indicates the type of file system object returned as part
// of the fsobject_t structure

typedef [v1_enum] enum {

	FSOBJECT_PHYSICAL		= 1,			// Object is a physical resource

} fsobjecttype_t;

//-----------------------------------------------------------------------------
// fsobject_t
//
// Structure that describes a virtual file system object.  If the object is
// determined to be physical, no fshandle_t will be provided as the client 
// application is expected to handle the file operations directly

typedef struct {

	fshandle_t			fshandle;				// fshandle or zero if physical
	fsobjecttype_t		objecttype;

	[switch_is(objecttype)] union  {

		// physical
		//
		// Node that represents a physical file system object
		[case(FSOBJECT_PHYSICAL)] struct {

			wcharptr_t				ospath;

		} physical;
	};

} fsobject_t;

//-----------------------------------------------------------------------------
// Interface RemoteSystemCalls

[
	version(1.0),
	uuid(65AF53FB-CA7B-43DA-886E-A5F501FBACA9),
	pointer_default(unique),
	endpoint("ncalrpc:[vm.service.RemoteSystemCalls]"),
]

interface RemoteSystemCalls
{
	__int3264 rpc005_open		([in] charptr_t pathname, [in] int32_t flags, [in] mode_t mode, [out, ref] fsobject_t* fsnode);
	__int3264 rpc006_close		([in] fshandle_t fshandle);
	__int3264 rpc010_unlink		([in] charptr_t pathname);

	__int3264 rpc014_mknod		([in] charptr_t pathname, [in] mode_t mode, [in] dev_t dev, [out] fshandle_t* fshandle);

	__int3264 rpc295_openat		([in] fshandle_t dirhandle, [in] charptr_t pathname, [in] int32_t flags, [in] mode_t mode, [out] fshandle_t* fshandle);
	__int3264 rpc297_mknodat	([in] fshandle_t dirhandle, [in] charptr_t pathname, [in] mode_t mode, [in] dev_t dev, [out] fshandle_t* fshandle);
}

// RemoteSystemCalls endpoint constant
cpp_quote("#ifdef _UNICODE")
cpp_quote("#define ENDPOINT_REMOTESYSTEMCALLS reinterpret_cast<unsigned short*>(L\"vm.service.RemoteSystemCalls\")")
cpp_quote("#else")
cpp_quote("#define ENDPOINT_REMOTESYSTEMCALLS reinterpret_cast<unsigned char*>(\"vm.service.RemoteSystemCalls\")")
cpp_quote("#endif")

//---------------------------------------------------------------------------
